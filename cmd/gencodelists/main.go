// gencodelists generates code lists for human-readable descriptions
// of codes used in electronic invoicing (UNTDID, UNECE, etc.).
package main

import (
	"encoding/csv"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"sort"
	"strings"
	"text/template"
)

const (
	untdidURL = "https://raw.githubusercontent.com/invopop/gobl/main/data/catalogues/untdid.json"
	uneceURL  = "https://raw.githubusercontent.com/datasets/unece-units-of-measure/main/data/units-of-measure.csv"
)

type codeEntry struct {
	Code string
	Name string
}

func main() {
	output := flag.String("output", "", "output file path")
	pkg := flag.String("package", "codelists", "package name")
	flag.Parse()

	if *output == "" {
		log.Fatal("--output flag is required")
	}

	log.Println("Fetching code lists...")

	// Fetch document types
	docTypes, err := fetchDocumentTypes()
	if err != nil {
		log.Fatalf("Failed to fetch document types: %v", err)
	}
	log.Printf("Fetched %d document types", len(docTypes))

	// Fetch unit codes
	unitCodes, err := fetchUnitCodes()
	if err != nil {
		log.Fatalf("Failed to fetch unit codes: %v", err)
	}
	log.Printf("Fetched %d unit codes", len(unitCodes))

	// Generate Go code
	if err := generateGoCode(*output, *pkg, docTypes, unitCodes); err != nil {
		log.Fatalf("Failed to generate code: %v", err)
	}

	log.Printf("Generated %s", *output)
}

func fetchDocumentTypes() ([]codeEntry, error) {
	resp, err := http.Get(untdidURL)
	if err != nil {
		return nil, err
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status: %s", resp.Status)
	}

	var data struct {
		Extensions []struct {
			Key    string `json:"key"`
			Values []struct {
				Code string          `json:"code"`
				Name map[string]string `json:"name"`
			} `json:"values"`
		} `json:"extensions"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return nil, err
	}

	// Find document type extension
	for _, ext := range data.Extensions {
		if ext.Key == "untdid-document-type" {
			var entries []codeEntry
			for _, val := range ext.Values {
				entries = append(entries, codeEntry{
					Code: val.Code,
					Name: val.Name["en"],
				})
			}
			return entries, nil
		}
	}

	return nil, fmt.Errorf("document types not found in UNTDID data")
}

func fetchUnitCodes() ([]codeEntry, error) {
	resp, err := http.Get(uneceURL)
	if err != nil {
		return nil, err
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status: %s", resp.Status)
	}

	reader := csv.NewReader(resp.Body)

	// Read header
	if _, err := reader.Read(); err != nil {
		return nil, err
	}

	var entries []codeEntry
	seen := make(map[string]bool)

	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, err
		}

		// CSV format: Status,CommonCode,Name,Description,LevelAndCategory,Symbol,ConversionFactor
		if len(record) < 3 {
			continue
		}

		status := record[0]
		code := strings.TrimSpace(record[1])
		name := strings.TrimSpace(record[2])

		// Skip deprecated codes (Status = "X")
		if status == "X" {
			continue
		}

		// Skip empty or duplicate codes
		if code == "" || name == "" || seen[code] {
			continue
		}

		seen[code] = true
		entries = append(entries, codeEntry{
			Code: code,
			Name: name,
		})
	}

	// Add UNECE Recommendation 21 codes not in Recommendation 20 CSV
	// XPP is from Rec 21 (codes prefixed with X) and widely used in PEPPOL/ZUGFeRD
	// XPP = Piece: a loose or unpacked article
	customCodes := []codeEntry{
		{Code: "XPP", Name: "piece"},
	}

	for _, custom := range customCodes {
		if !seen[custom.Code] {
			entries = append(entries, custom)
		}
	}

	// Sort by code
	sort.Slice(entries, func(i, j int) bool {
		return entries[i].Code < entries[j].Code
	})

	return entries, nil
}

func generateGoCode(output, pkg string, docTypes, unitCodes []codeEntry) error {
	tmpl := template.Must(template.New("codelists").Parse(codeTemplate))

	f, err := os.Create(output)
	if err != nil {
		return err
	}
	defer func() { _ = f.Close() }()

	data := struct {
		Package      string
		DocumentTypes []codeEntry
		UnitCodes     []codeEntry
	}{
		Package:       pkg,
		DocumentTypes: docTypes,
		UnitCodes:     unitCodes,
	}

	return tmpl.Execute(f, data)
}

const codeTemplate = `// Code generated by gencodelists. DO NOT EDIT.

package {{.Package}}

// documentTypes maps UNTDID 1001 document type codes to human-readable names.
// Source: https://github.com/invopop/gobl (Apache 2.0)
var documentTypes = map[string]string{
{{- range .DocumentTypes}}
	"{{.Code}}": "{{.Name}}",
{{- end}}
}

// unitCodes maps UNECE Recommendation 20 unit codes to human-readable names.
// Source: https://github.com/datasets/unece-units-of-measure
var unitCodes = map[string]string{
{{- range .UnitCodes}}
	"{{.Code}}": "{{.Name}}",
{{- end}}
}
`
